# 多变量图 {#cha:gallery3}

## 散点图矩阵 {#sec:scatterplot-matrix}


散点图矩阵（Scatterplot Matrices）是散点图的高维扩展，它的基本构成是普通散点图，只是将多个变量的两两散点图以矩阵的形式排列起来，就构成了所谓的散点图矩阵，它通常包含 $p\times p$ 个窗格（$p$ 为变量个数）。散点图矩阵从一定程度上克服了在平面上展示高维数据的困难，对于我们查看变量之间的两两关系非常有用。

R 中散点图矩阵的函数为 `pairs()` ，其用法如下：

```{r pairs-usage, results='asis'}
usage2(usage(pairs.default, output = FALSE))
usage2(usage(graphics:::pairs.formula, output = FALSE))
```


散点图矩阵函数是泛型函数，可以直接接受数据矩阵或者公式作为参数。 `x` 是一个矩阵或数据框，包含了要作散点图的那些变量； `labels` 是变量名称（标签）； `panel` 参数给定一个画散点图的函数，这个函数将应用在每一格图形中；有时候我们并不需要统一的散点图函数，这时可以利用 `lower.panel` 和 `upper.panel` 来分别指定上三角窗格和下三角窗格中的作图函数，也就意味着上三角和下三角窗格中的图形（不一定非得是散点图）可以不一样； `diag.panel` 和 `text.panel` 分别指定对角线窗格上的作图函数和添加文本标签的函数； `label.pos` 指定文本标签的位置； `cex.labels` 指定标签的缩放倍数； `font.labels` 指定标签的字体样式； `row1attop` 为逻辑值，指定散点图的第 1 行出现在顶部还是底部（按常规讲，前者是矩阵的形式，后者是图的形式，因为矩阵通常是从上至下、从左至右，而图的坐标是从下至上、从左至右）； `gap` 设定窗格之间的间距大小。

图 \@ref(fig:pairs)
是对鸢尾花数据 `iris` 所作的散点图矩阵，注意其中的上三角和下三角作图函数是如何定义的。对角线窗格显示的是自定义的直方图，定义如下：

```{r define-pairs-panel}
# 观察如何使用 hist() 做计算并用 rect() 画图
panel.hist <- function(x, ...) {
  usr <- par("usr")
  on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5))
  h <- hist(x, plot = FALSE)
  nB <- length(breaks <- h$breaks)
  y <- h$counts / max(h$counts)
  rect(breaks[-nB], 0, breaks[-1], y, col = "beige")
}
```

(ref:fig-pairs-s) 鸢尾花数据的散点图矩阵

(ref:fig-pairs) 鸢尾花数据的散点图矩阵：上三角区域为不同样式的点，对应着不同种类的鸢尾花，对角线的直方图展示了花瓣花萼长宽的一维分布，下三角区域用平滑曲线显示了变量之间的关系

```{r pairs,fig.width=4.8,fig.height=4.8,fig.cap="(ref:fig-pairs)",fig.scap="(ref:fig-pairs-s)"}
idx <- as.integer(iris[["Species"]])
pairs(iris[1:4],
      upper.panel = function(x, y, ...)
        points(x, y, pch = c(17, 16, 6)[idx], col = idx),
      pch = 20, oma = c(2, 2, 2, 2),
      lower.panel = panel.smooth, diag.panel = panel.hist
)
```


我们可以看到，主对角线上用了直方图，从中我们可以看到四个变量各自的分布情况；上三角窗格中用不同样式的点标记出了鸢尾花的不同类型（回顾图 \@ref(fig:point-iris)
）；下三角窗格中简化了点的样式，但是利用函数 `panel.smooth()` 添加了一条平滑曲线，对鸢尾花的四个变量两两之间的关系作出了一种非参数概括（散点图平滑技术，参见 @Cleveland79）。

在变量数目较多时，我们不妨将散点图矩阵作为一种探索变量之间相关关系的工具，它比起相关系数矩阵等统计指标来优势在于：散点图矩阵展示了所有原始数据，这样我们可以看到变量之间的任何关系（线性或非线性、离群点），从而避免被单一的统计指标所误导。


## 三维透视图 {#sec:persp}

```{r}
# 代码参见 example(persp)
```


(ref:fig-persp-s) 新西兰 Maunga Whau 火山的三维透视图

(ref:fig-persp) 新西兰 Maunga Whau 火山的三维透视图

```{r persp,fig.height=4,fig.width=7,echo=FALSE,fig.cap="(ref:fig-persp)",fig.scap="(ref:fig-persp-s)"}
z <- volcano
x <- 4 * (1:nrow(z))
y <- 4 * (1:ncol(z))
par(mar = rep(0, 4))
persp(x, y, z,
  theta = 150, phi = 30, col = "green3",
  scale = FALSE, ltheta = -120, shade = 0.75, border = NA,
  box = FALSE
)
```

相比其二维平面图形来说，三维透视图（Perspective Plot）可能在视觉上更具有吸引力。三维透视图的数据基础是网格数据（回顾 \@ref(sec:contour) 小节和图 \@ref(fig:contour-grid)），它将一个矩阵中包含的高度数值用曲面连接起来，便形成了我们所看到的三维透视图。前面等高图一节中我们曾经用到过透视图，参见图 \@ref(fig:persp-pop)
。

R 中透视图的函数为 `persp()` ，其用法如下：

```{r persp-usage, results='asis'}
usage2(usage(graphics:::persp.default, output = FALSE))
```


透视图函数为泛型函数，主要体现在它的第一个参数既可以是单个 `x` 向量，也可以是一个包含了向量 `x` 和 `y` 的列表，这一点与等高图函数是类似的。参数 `x` 和 `y` 分别是两个数值向量， `z` 是一个与前两个参数对应的矩阵； `xlim` 、 `ylim` 和 `zlim` 分别设定三个坐标轴的范围； `xlab` 、 `ylab` 和 `zlab` 分别设定三个坐标轴的标题； `theta` 和 `phi` 分别设定立体图形左右方向和上下方向旋转的角度； `r` 设定眼睛离透视图中心的距离，这个距离的远近会给我们一种从远近看物体的感觉； `d` 设定立体效果的程度，大于 1 的值会减弱立体程度，反之会增强立体程度； `scale` 为逻辑值，决定是否对三个坐标进行缩放，若为 `TRUE`，则 `x` 、 `y` 和 `z` 都会被缩放到 $[0, 1]$ 范围内，若为 `FALSE`，那么所有坐标轴都按照数据的原始量纲处理，这样可以得到数据的真实比例； `expand` 为 z 轴的缩放因子，它决定了 z 轴的长短； `col` 为组成曲面的所有小方块的颜色； `border` 为组成曲面的小方块的边框样式，设置为 `NA` 可以去掉边框； `ltheta` 和 `lphi` 设置透视图的光源位置； `shade` 决定的阴影效果； `box` 为逻辑值，设定透视图是否需要画外框； `axes` 决定是否画坐标轴； `nticks` 为坐标轴刻度线的数目； `ticktype` 设定坐标轴刻度类型，取值 `'simple'` 则简单画箭头表示坐标轴，`'detailed'` 则将详细的刻度标记在坐标轴上。

图 \@ref(fig:persp-pop) 为我们展示了新西兰 Maunga Whau 火山的真面目，读者不妨将这幅立体图形与前面章节中的等高图 \@ref(fig:filled-contour) 和颜色图 \@ref(fig:image) 对应起来并分别体会等高图和颜色图是怎样展示三维数据的。

(ref:fig-persp-add-s) 向三维透视图中添加图形元素的展示

(ref:fig-persp-add) 向三维透视图中添加图形元素的展示：`trans3d()` 函数的应用

```{r persp-pop,fig.width=6,fig.height=4,echo=FALSE,fig.cap="(ref:fig-persp-add)",fig.scap="(ref:fig-persp-add-s)"}
x <- seq(-10, 10, length = 30)
y <- x
f <- function(x, y) {
  r <- sqrt(x^2 + y^2)
  10 * sin(r) / r
}
z <- outer(x, y, f)
z[is.na(z)] <- 1
par(mar = c(4, 4, 0.2, 0.2))
res <- persp(x, y, z,
  theta = 30, phi = 30, expand = 0.5, col = "lightblue",
  ltheta = 120, shade = 0.75, ticktype = "detailed",
  xlab = "X", ylab = "Y", zlab = "Sinc( r )"
)
xE <- c(-10, 10)
xy <- expand.grid(xE, xE)
points(trans3d(xy[, 1], xy[, 2], 6, pmat = res), col = 2, pch = 16)
lines(trans3d(x, y = 10, z = 6 + sin(x), pmat = res), col = 3)

phi <- seq(0, 2 * pi, len = 201)
r1 <- 7.725 # radius of 2nd maximum
xr <- r1 * cos(phi)
yr <- r1 * sin(phi)
lines(trans3d(xr, yr, f(xr, yr), res), col = "pink", lwd = 2)
```


**grDevices** 包提供了一个相关的三维透视图转换函数 `trans3d()` ，它可以将一个空间的点的三维坐标根据透视图的特征转换为平面坐标，这样我们就可以很方便地使用一般的底层作图函数向立体图中添加图形元素。图 \@ref(fig:persp-pop)
就是这样的一个例子，读者可以参考 `persp()` 帮助文件中的示例。

最后，我们介绍另一个专门的三维图形包：**scatterplot3d**
[@Ligges03]，这个包提供了更方便且美观的作图函数 `scatterplot3d()` ；在 **lattice** 包 [@Sarkar08] 中也有三维图形函数 `cloud()` 和 `wireframe()` ；此外，**rgl** 包 [@rgl] 也不失为一个非常便利的三维数据探索工具，它基于 OpenGL 系统写成，最大的优势在于它生成的三维图形可以通过鼠标交互操作，例如拖拽旋转等，立体效果非常逼真；**rgl** 系统到后面 \@ref(sec:rgl) 小节我们再详细介绍。

## 平滑散点图 {#sec:smoothScatter}


平滑散点图的基础是散点图，但它并不直接将散点画出来，而是基于二维核密度估计 [@KernSmooth] 用特定颜色深浅表示某个位置的密度值大小，默认颜色越深说明二维密度值越大，即该处数据点越密集。二维核密度估计的原理和一维情况类似：一维核密度估计是在直线上按照距离远近对每个数据点加权，距离越近则对密度值贡献越大，因此数据点密集的地方的核密度值也相应大，二维情况下只是距离的计算放到了平面上，加权思想相同。

由于平滑散点图大致保留了原始数据点的位置，因此两个变量之间的关系仍然可以从图中看出来，这一点和普通的散点图类似。平滑散点图进一步的优势在于它同时还显示了二维变量的密度，从密度中我们也许可以观察到局部的聚类现象（大块的深色）。

(ref:fig-smoothScatter-s) BinormCircle 数据的平滑散点图

(ref:fig-smoothScatter) BinormCircle 数据的平滑散点图：基于核密度估计找出散点图中暗含的圆圈（圆圈上的颜色深）

```{r smoothScatter,fig.width=4.5,fig.height=4.5,fig.cap="(ref:fig-smoothScatter)",fig.scap="(ref:fig-smoothScatter-s)"}
par(mar = c(4, 4, 0.3, 0.1))
smoothScatter(BinormCircle)
```
```{r smoothScatter-ggplot1,fig.width=5,fig.height=4,eval=FALSE}
library(ggpointdensity)
ggplot(data = BinormCircle, aes(x = V1, y = V2)) +
  geom_pointdensity(adjust = 0.1)
```

```{r smoothScatter-ggplot2,echo=FALSE}
knitr::include_graphics(path = "images/smoothScatter-ggplot.png")
```

从计算的角度来说，我们首先将平面划分为 $n\times n$ 的网格，计算每个网格点上的二维密度值，然后用颜色将密度值大小表达出来。关于这一点，可将图 \@ref(fig:smoothScatter) 放大 8 倍，就立刻理解"网格"的意思了。

R 中平滑散点图的函数为 `smoothScatter()` ，其用法如下：

```{r smoothScatter-usage, results='asis'}
usage2(usage(smoothScatter, output = FALSE))
```

\noindent 其中 `x` 和 `y` 是两个数值向量，或者如果不提供 `y` 的话，可以提供一个两列的矩阵/数据框等给 `x` ； `nbin` 为横纵坐标方向上划分网格的数目，可以是长度为 1 或 2 的整数向量； `bandwidth` 为计算核密度估计时使用的带宽； `colramp` 为生成颜色向量的函数，默认生成从白色到蓝色渐变的颜色向量； `nrpoints` 为需要画出来的点的数目，因为平滑散点图的目的不是画散点，而是画颜色块，但有时候图形中某些地方的密度估计非常低，因此对应颜色也非常浅，导致读者难以察觉那些地方还有数据点的存在，此时不妨直接将这些"离群点"直接画出来，注意画点时按密度值从小到大的顺序画，一直画到第 `nrpoints` 个点；其它参数几乎都是画图的一般参数，此处不再介绍。

图 \@ref(fig:smoothScatter) 是 **MSG** 包中 `BinormCircle` 数据的平滑散点图，其原始散点图参见图 \@ref(fig:scatter-alpha) 左图。由于使用了核密度估计，这批数据中藏着的圆圈很容易就能被发现，因为它们的密度值都很大，导致这一圈上颜色也就相应较深。平滑散点图看起来和图 \@ref(fig:scatter-alpha) 右图比较相似，但前者蕴含了更多的数理统计背景。不过，我们也不必一味追求数学理论，透明色可叠加这一点性质体现出的原理又何尝不是一种密度估计呢？


## 星状图、蛛网图、雷达图 {#sec:stars}

(ref:fig-stars-s) Motor Trend 杂志 1974 年汽车数据的星状图

(ref:fig-stars) Motor Trend 杂志 1974 年汽车数据的星状图

```{r stars,fig.width=5,fig.height=4.8,fig.cap="(ref:fig-stars)",fig.scap="(ref:fig-stars-s)"}
# 预设调色板，stars() 默认用整数来表示颜色
palette(rainbow(12, s = 0.6, v = 0.75))
stars(mtcars[, 1:7], len = 0.8, key.loc = c(14, 1.5), ncol = 7, 
      main = "", draw.segments = TRUE)
palette("default") # 恢复默认调色板
```


星状图（Star Plot）、蛛网图（Spider Plot）和雷达图（Radar Plot）本质上是一类图形，它们都用线段离中心的长度来表示变量值的大小，这三种图形名称的区别在于星状图用来展示很多个多变量个体，各个个体的图形相互独立，从而整幅图形看起来就像很多星星，而蛛网图和雷达图将多个多变量个体放在同一张图形上，看起来就像是蛛网或雷达的形状，这样重叠的图形就称为蛛网图或者雷达图。简单说来，就是星状图有若干个中心，而蛛网图和雷达图只有一个中心。

R 中星状图的函数为 `stars()` ，其用法如下：

```{r stars-usage, warning=FALSE, results='asis'}
usage2(usage(stars, output = FALSE))
```

参数 `x` 为一个多维数据矩阵或数据框，每一行数据将生成一个星形； `full` 为逻辑值，决定了是否使用整圆（或半圆）； `scale` 决定是否将数据标准化到区间 $[0,1]$ 内； `radius` 决定是否画出半径； `labels` 为每个个体的名称，默认为数据的行名； `locations` 以一个两列的矩形给出每个星形的放置位置，默认放在一个规则的矩形网格上，若提供给该参数一个长度为 2 的向量，那么所有的星形都将被放在该坐标上，从而形成蛛网图或雷达图； `nrow` 和 `ncol` 分别给定网格的行数和列数以便摆放星形，默认 `nrow` 等于 `ncol` ； `len` 为半径和线段的缩放倍数； `key.loc` 提供比例尺的坐标位置； `key.labels` 为比例尺的标签，默认为变量名称； `key.xpd` 设定比例尺的作图范围，参见 \@ref(sec:par) 小节（`par('xpd')`）； `flip.labels` 设定每个星形底部的名称是否互相上下错位，以免名称太长导致文本之间互相重叠； `draw.segments` 设定是否作线段图，即：每个变量以一个扇形表示； `col.segments` 设定每个扇形区域的颜色（当 `draw.segments` 为 `FALSE` 时无效）； `col.stars` 设定每个星形的颜色（当 `draw.segments` 为 `TRUE` 时无效）； `axes` 决定是否画坐标轴； `frame.plot` 决定是否画整个图形的边框； `add` 决定是否将图形添加到当前图形上。

图 \@ref(fig:stars)
为数据 `mtcars` 的星状图，一共使用了 7 个变量：`mpg` 为每加仑汽油可行驶英里数，`cyl` 为汽缸数，`disp` 为汽缸排量，`hp` 为马力，`drat` 为背齿轮比，`wt` 为车重，`qsec` 为行驶 $1/4$ 英里的时间。从图中可以看到各种品牌和型号的汽车在这 7 方面的指标和性能表现。以星状图展示数据可以让我们很快找到一些有突出特征的个体，从而省去了在大批数据中逐个寻找、排序的过程。

```{r mtcars-data}
# mtcars 数据前 7 列的前 6 行
head(mtcars[, 1:7])
```

## 符号图 {#sec:symbols}


符号图是用各种符号展示高维数据的图示工具，它的主要思想是将高维数值体现在图形中符号的特征上。因为受到平面的限制，我们对于高维数据的展示方法总是很有限，仅仅是对于二维数据的展示最为方便，对更高维度的如三维、四维甚至五维的数据相对缺乏好的工具。由于符号的存在，使得我们可以将高于二维的数据"寄托"在符号的各种特征上，如：以矩形为散点图的基本符号，那么我们可以用其长宽分别代表两个变量，这样一幅图形中至少可以放置四个变量；类似地，我们可以以圆圈、正方形、多边形、箱线图、温度计等符号为散点图中的"点"，于是散点图就可以被扩展为高维数据的展示工具。

R 中的符号图函数为 `symbols()`，它提供了六种基本符号：圆、正方形、长方形、星形、温度计和箱线图，分别由相应的参数指定； `symbols()` 的用法如下：

```{r symbols-usage, results='asis'}
usage2(usage(symbols, output = FALSE))
```


如前所述，符号图的基础是散点图，因此首先要给出两个参数 `x` 和 `y` 以便作散点图，然后在散点的位置上画出符号；接下来的六个参数分别指定符号的形状：

circles

:   圆：一个数值向量，给定圆的半径（实际上是与圆的半径成比例，下同）

squares

:   正方形：一个数值向量，给定正方形的边长

rectangles

:   长方形：一个矩阵，列数为 2，这两列分别给定长方形的宽和高

stars

:   星形：一个矩阵，列数 $\geq3$，类似雷达图，给定从星星中心向每个方向的射线的长度（严格说是线段），最终这些射线的端点会连接起来形成一个星形，但射线本身不会被画出来；缺失值将被视作 0 （星形在符号图中并不直观，推荐直接使用星状图，见 \@ref(fig:stars) 小节）

thermometers

:   温度计：一个矩阵，列数为 3 或 4，前两列分别给定温度计的宽和高；若矩阵为三列，那么第三列为温度计内的"温度"高度，注意这一列的值应该小于 1，否则温度的填充会超过温度计的范围；若矩阵为四列，那么温度将按照第三列与第四列的比率进行填充，同样，这两列的比率需要小于 1

boxplots

:   箱线图：一个矩阵，列数为 5，前两列分别给定箱子的宽和高，第三、四列分别给定两条线（下线和上线）的长度，第五列与温度计类似，给定箱线图内的中位数标记线在箱子内部的高度比例，因此这一列数据也需要在 $[0,1]$ 范围内；这里只是借用了箱线图的称谓，符号图中的箱线与真正的箱线图之间没有关系

(ref:fig-symbols-s) 符号图提供的六种基本符号

(ref:fig-symbols) 符号图提供的六种基本符号

```{r symbols,fig.width=4.8,fig.height=4.8,fig.cap="(ref:fig-symbols)",fig.scap="(ref:fig-symbols-s)"}
demo("symbols_all", echo = FALSE, package = "MSG")
```


不难看出，这六种符号图能展示的数据维度分别为 3、3、4、$\geq5$、5 或 6、7；参数 `inches` 为逻辑值，控制着符号的大小，若为 `TRUE`（默认），那么图中所有符号的最长长度（边长或半径等等）将被设置为 1 英寸（约 2.54 厘米），其它长度按比例缩放，若该参数取一个正数，那么类似地，所有符号的最长长度的英寸值为该正数，因此 `TRUE` 和 1 的效果是相同的，如果 `inches` 为 `FALSE` 那么符号的长度单位取相应坐标轴的单位，例如符号中的 1 长度即为坐标轴上的 1 单位； `add` 为逻辑值，设定是否将符号图添加到现有图形上； `fg` 为符号的前景色； `bg` 为符号的背景色或填充色；其它参数用来添加标题、设定坐标轴范围等。

图 \@ref(fig:symbols)
给出了六种基本符号的形状，注意观察各种符号是如何利用自己的特征将高维数据表达出来的。下面我们通过实际数据来看符号图在展示数据时的效果，以 2005 年中国 31 省市自治区的人口特征数据为例，我们选取了人口自然增长率、年底人口总数、城镇人口比重、人口预期寿命和高学历人数五个变量作为国民素质的刻画指标，数据见 **MSG** 包中的 ChinaPop.R 文件（可用 `source()` 函数载入，见以下代码），这些数据都可以从《中国统计年鉴》中获得。


```{r ChinaPop-data}
source(system.file("extdata", "ChinaPop.R", package = "MSG"), encoding = "UTF-8")
head(ChinaPop)
```

(ref:fig-symbols-pop-s) 中国 31 地区五大国民素质特征分布温度计图

(ref:fig-symbols-pop) 2005 年中国 31 地区五大国民素质特征分布温度计图

```{r symbols-pop,fig.width=5.8,fig.height=6,results="hide",fig.cap="(ref:fig-symbols-pop)",fig.scap="(ref:fig-symbols-pop-s)"}
demo("ChinaPop", package = "MSG")
```


图 \@ref(fig:symbols-pop) [@Xie08] 融合了多种图形和图形元素，它的基础是一幅等高图（回顾 \@ref(sec:contour) 小节和图 \@ref(fig:contour-pop)），利用人口预期寿命和高学历人数两个变量计算二维密度，画出等高线，便完成了底图的制作；然后我们通过人口预期寿命和高学历人数两个变量的数值往图中添加温度计符号，温度计宽代表增长率，高代表总人口数，温度代表城镇人口比重；然后我们用 `text()` 函数将各省市的文本标签添加到图中。经过这些图形元素的表达，全国 31 省市自治区的五项人口特征便一目了然，例如通过温度计的高度可以观察出三个人口大省广东、山东、河南（相应的人口总量小的地区如西藏、青海、宁夏等也容易看出），由宽度可以看出西藏、青海、宁夏、新疆等省市自治区的人口自然增长率非常高（而北京、上海、天津等直辖市的增长率则很低），从温度指示的情况来看，北京、上海和天津三大直辖市的城镇人口比例要远高于其它地区；从整幅散点图来看，人口平均预期寿命与高学历者人数呈比较明显的正相关关系。箱线图和坐标轴须分别刻画了人口平均预期寿命与高学历者人数各自的分布特征。这样，我们就完成了在平面上描述五维变量的任务。从这幅图我们可以看出掌握基本图形元素使用的用处和重要性——没有一种统计软件能够提供现成的模块或函数来完成类似的任务。

## 脸谱图 {#sec:faces}


脸谱图由 @Chernoff73 提出，它以一种非常形象有趣的方式来展示多元数据：人的脸部（确切来说是头部）有很多特征，例如眼睛大小、眉毛弧度、脸宽、鼻高等。由于这些特征都可以用数值大小来测量，因此我们也可以反过来将一批数值对应到这些脸部特征上来，如数据的第一列控制眼睛大小、第二列控制嘴巴大小等，每一行观测数据都可以像这样画出一个人脸来。由于人眼通常很容易辨别这些脸谱的具体特征（如谁的脸胖、谁笑得最夸张），因此脸谱图能很好反映其背后的数值大小。

**TeachingDemos** 包 [@TeachingDemos] 提供了两个脸谱图函数 `faces()` 和 `faces2()` ，两个函数能反映的面部特征不尽相同，各有所长，例如 `faces()` 可以画头发和耳朵，但 `faces2()` 可以画更多的变量。这里我们只介绍后者，读者可以阅读前者的帮助文档了解更多信息。`faces2()` 的用法如下：

```{r faces2-usage, warning=FALSE, results='asis'}
library(TeachingDemos)
usage2(usage(faces2, output = FALSE))
```

\noindent 其中 `mat` 是主要参数，它是一个数据矩阵，每一行对应着一张脸谱，脸谱中各个部位的特征对应着矩阵中的列； `which` 也是一个重要参数，它用来指定数据矩阵中的每一列分别对应着何种面部特征，它是一个整数向量，向量的每个元素取值在 1 到 18 之间，分别表示：

1

:   额头和脸之间的横线宽度（一张脸谱上半部分为额头，下半部分为脸）

2

:   额头和脸的相对高度（取值越大则额头越矮脸越高）

3

:   脸高

4

:   上半边脸的宽度

5

:   下半边脸的宽度

6

:   鼻子长度

7

:   嘴巴高度

8

:   嘴巴弧度（绝对值应小于 9）

9

:   嘴巴宽度

10

:   眼睛高度

11

:   两只眼睛之间的距离（取值 0.5\~0.9）

12

:   眼睛和眉毛的弧度

13

:   眼睛圆圈的形状（取值越大越呈椭圆形，越小越圆）

14

:   眼睛大小

15

:   眼珠和眉毛的位置（越大越靠左，越小越靠右）

16

:   眉毛高度

17

:   眉毛弧度

18
:   眉毛宽度

这些不同取值结合后面的例子就更容易理解了； `nrows` 和 `ncols` 决定按多少行列排列这些脸谱，默认尽量以方形 $n\times n$ 的样式排版； `scale` 决定如何标准化数据，默认对列标准化使之取值在 $[0, 1]$ 上；若数据不足 18 列，那么 fill 参数中的值就会补充不足的列的取值； ... 参数都将传给 `text()` 函数往图中加标签（默认是行名）。

(ref:fig-faces2-s) 部分汽车数据的脸谱图

(ref:fig-faces2) 部分汽车数据的脸谱图：谁的脸宽？谁的鼻子长？谁的眼睛大？

```{r faces2,fig.width=5.8,fig.height=6.2,fig.cap="(ref:fig-faces2)",fig.scap="(ref:fig-faces2-s)"}
faces2(mtcars[, c("hp", "disp", "mpg", "qsec", "wt")], which = c(14, 9, 11, 6, 5))
```


图 \@ref(fig:faces2)
是汽车数据 `mtcars` 中 5 个变量的脸谱图，这 5 个变量分别为马力 `hp`、气缸排量 `disp`、每加仑行驶英里数 `mpg`、行驶 1/4 英里时间 `qsec` 和车重 `wt`。我们将 which 参数设定为 `c(14, 9, 11, 6, 5)`，也就是指定这几个变量分别用眼睛大小、嘴宽、眼距、鼻长和下半脸宽来表示，所以整幅图形的解读方式就是：眼睛瞪得越大，说明该车型的马力越大；嘴越宽则气缸排量越大；两眼距离越大则越省油（每加仑汽油跑得越远）；鼻子越长则说明跑得越快；脸越宽则说明车越重。那么，我们很容易看出，Maserati Bora 马力最强（大眼睛），Lincoln Continental 等车气缸排量较大（宽嘴），Honda Civic 等车比较省油（眼距大），Merc 230 跑得最快（鼻子长），Lincoln Continental 等车最重（脸胖）。这里我们尽量将这几个汽车性能指标形象化到合适的脸部特征上（如瞪着大眼睛表示马力大），读者在遇到具体的案例数据时，不妨也仔细考虑一下指标的实际意义以及安排它们到哪个面部表情上。很多人都知道宏基施振荣的"微笑曲线"并且对之印象深刻，其原因何尝不是因为这条曲线形象而且直观呢？

在众多统计图形中，脸谱图可算是最有幽默味道的一种，读者不妨在一些轻松的场合或听众精力不集中时尝试使用这种图形，也许能让听众感觉眼前一亮，主动解读图中的数据。

## 泰勒图

## 条件分割图 {#sec:coplot}


条件分割图（Conditioning Plot）的思想源自于统计学中的条件分布，即：给定某一个（或几个）变量之后看我们所关心的变量的分布情况。在条件分割图中，这种"分布"主要指的是两个变量之间的关系，通常以散点图表示。

条件分割图可以看作是对散点图的进一步深入发掘，它可以以一个或者两个条件变量作为所有数据的划分条件，条件变量在图形的边缘用灰色矩形条标记出变量的取值范围，每个矩形条对应着一幅散点图（严格来说此时应该称作"条件散点图"），这就是条件分割图的基本做法。后面我们会结合例子详细说明。

R 中条件分割图的函数为 `coplot()`，其用法如下：

```{r coplot-usage, results='asis'}
usage2(usage(coplot, output = FALSE))
usage2(usage(co.intervals, output = FALSE))
```


参数 `formula` 为一个公式，形式为 `y ~ x | a`（一个条件变量）或 `y ~ x | a * b`（两个条件变量），"`|`" 后面即为条件变量； `data` 为数据，其中包含了 `x` 、 `y` 、 `a` 和 `b` 等变量； `given.values` 指定条件变量的取值范围； `panel` 参数为该函数的关键参数，它决定了每一幅散点图的画法，默认只是画点，我们可以将其任意扩展为我们需要的图示功能，如添加回归直线等等； `rows` 和 `columns` 参数用来设定散点图的摆放行数和列数； `col` 和 `pch` 分别设定散点图中点的颜色和样式； `bar.bg` 给定条件变量指示条的填充颜色； `number` 和 `overlap` 传给 `co.intervals()` 函数用来计算划分连续变量的区间，前者设定划分段数，后者设定区间之间的重叠比例，如：

```{r co-intervals-demo}
co.intervals(1:10, number = 5, overlap = 0.5)
```

上述代码将数字 `1:10` 划分为了 5 段，每段长度为 2，重叠长度为 1，因此重叠比例为 0.5。条件分割图中散点图的顺序是从左到右、从下到上，分别与条件变量从左到右、从下到上的指示条对应。

(ref:fig-coplot-s) 给定震源深图的地震经纬度条件分割图

(ref:fig-coplot) 给定震源深图的地震经纬度条件分割图：四幅散点图有相同的坐标系，震源深度按左下、右下、左上、右上的顺序逐渐增加，可以看到地震发生地点逐渐在向斐济岛靠近

```{r coplot,fig.width=4.8,fig.height=4.8, fig.cap="(ref:fig-coplot)", fig.scap="(ref:fig-coplot-s)"}
par(mar = rep(0, 4), mgp = c(2, .5, 0))
library(maps)
coplot(lat ~ long | depth,
  data = quakes, number = 4,
  ylim = c(-45, -10.72), panel = function(x, y, ...) {
    map("world2",
      regions = c("New Zealand", "Fiji"),
      add = TRUE, lwd = 0.1, fill = TRUE, col = "lightgray"
    )
    text(180, -13, "Fiji", adj = 1)
    text(170, -35, "NZ")
    points(x, y, col = rgb(0.2, 0.2, 0.2, .5))
  }
)
```


图 \@ref(fig:coplot)
展示了斐济岛（Fiji）附近的地震数据 `quakes`，数据包括地震发生地点的经纬度和震源的深度，我们想知道该地区在地震深度上分布是否均匀，因此我们令深度变量为条件变量，看在不同条件下地震发生地点（经纬度）是否有变化。从图中可以清楚看出，随着深度值的增加，地震发生地点逐渐由西向东、由南向北移动，震源较深的地震都发生在离斐济岛很近的东南侧。另外，图 \@ref(fig:coplot)
还展示了 `panel` 参数的用法，我们借助 **maps** 包 [@maps] 在散点图上添加了新西兰和斐济岛的地图作为辅助信息，关于 R 中地图的使用请参考 \@ref(sec:maps) 小节。

## 因素效应图 {#plot-design}


方差分析是很常见的统计模型，它的目的是比较不同组别之间的因变量均值是否有显著差异。因素效应图所展现的就是各种分组条件下因变量的水平，这里的水平可以由任何统计函数定义，例如均值、中位数等。

R 中因素效应图的函数为 `plot.design()`，其用法如下：

```{r plot-design-usage, results='asis'}
usage2(usage(plot.design, output = FALSE))
```

 `x` 为包含自变量（分类变量）的数据框，它也可以包含因变量，这种情况下第二个参数就不必提供了； `y` 为因变量； `fun` 为计算因变量水平的函数； `data` 为所用数据，包含自变量和因变量，当参数 `x` 为一个公式时，则会用到本参数提取数值，否则不必提供本参数；其它参数用于调整图形外观或设置图形标题、标记等。

(ref:fig-plot-design-s) 经纱断裂数据的因素效应图

(ref:fig-plot-design) 经纱断裂数据的因素效应图：每种羊毛（A、B）和拉力强度（L、M、H）下断裂数目的均值（上图）和中位数（下图）

```{r plot-design,fig.width=4.8,fig.height=5,fig.cap="(ref:fig-plot-design)",fig.scap="(ref:fig-plot-design-s)"}
par(mfrow = c(2, 1))
par(mar = c(4.5, 4, 0.2, 0.2))
plot.design(warpbreaks, col = "blue")
plot.design(warpbreaks, fun = median, col = "blue")
```


我们以经纱断裂数据 `warpbreaks` 为例，这个数据包含三个变量：经纱断裂数目 `breaks` 、羊毛种类 `wool`（A、B 两种）和拉力强度 `tension`（L、M、H 三种强度）。我们可以通过因素效应图看羊毛种类和拉力强度两个变量分别对经纱断裂根数的影响，如图 \@ref(fig:plot-design)
。上图中的刻度线展示出了不同羊毛种类和拉力强度下断裂根数的均值，下图展示的是中位数，两幅图有一定差异，说明数据的分布不对称（中位数和均值不相等）。我们也可以通过方差分析模型查看这两种因素的影响：

```{r warpbreaks-aov}
summary(aov(breaks ~ wool + tension, data = warpbreaks))
```


从以上结果中可以看出，拉力强度对经纱断裂根数有显著影响，而羊毛种类则不太显著。

总的来说，因素效应图是一种非常初级的统计图形，在数据的探索性分析中可能会起到一定作用。有时我们完全可以用一些分类汇总函数去计算各因素的效应（各组均值），例如分别按羊毛种类和拉力强度计算断裂数目的均值：

```{r warpbreaks-mean}
with(warpbreaks, tapply(breaks, wool, mean))
with(warpbreaks, tapply(breaks, tension, mean))
```

## 交互效应图

在回归模型或方差分析中，我们常遇到交互效应的概念。所谓交互效应，就是一个自变量对因变量的影响大小受另一个变量取值水平的影响，以二元回归为例，以下就是一个典型的含有交互效应的回归模型：

$$y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+\beta_{12}x_{1}x_{2}+\epsilon$$

令 $c_{2}\equiv\beta_{2}+\beta_{12}x_{1}$，上式可以改写为：

$$\begin{aligned}
y & =  \beta_{0}+\beta_{1}x_{1}+(\beta_{2}+\beta_{12}x_{1})x_{2}+\epsilon\\
 & \equiv  \beta_{0}+\beta_{1}x_{1}+c_{2}x_{2}+\epsilon\end{aligned}$$

显然，变量 $x_{2}$ 对因变量 $y$ 的影响系数 $c_{2}$ 受 $x_{1}$ 取值水平的控制，同理 $x_{1}$ 对  $y$ 的影响也受 $x_{2}$ 取值水平的影响。若模型中不存在交互项 $x_{1}x_{2}$，那么无论 $x_{1}$ 取值水平如何，$x_{2}$ 每增加 1 单位，$y$ 都会变化 $\beta_{2}$ 单位，对 $x_{2}$ 而言同理。以上数学原理用更直白的话来说就是，若因变量随一个变量的变化幅度与另一个变量的取值水平无关，那么模型中不存在交互效应。这个现象反映到图中，便有了交互效应图。它通常是针对分类变量而言的，看一个分类变量给定分类水平时，因变量在另一个分类变量各水平下的均值如何变化。这种变化趋势如果在前一个分类变量换一个取值水平后仍然保持相同的话，则说明这两个分类变量没有交互效应。

R 中交互效应图的函数为 `interaction.plot()`，用法如下：

```{r interaction-plot-usage, results='asis'}
usage2(usage(interaction.plot, output = FALSE))
```

\noindent 其中 `x.factor` 是横坐标上的分类变量； `trace.factor` 是第二个分类变量，按照这个分类变量的不同取值水平将 `x.factor` 分类下的因变量均值连接起来； `response` 是因变量； `fun` 是指定的对因变量汇总的函数，默认为均值，当然我们也可以指定其它计算函数如中位数 `median()` ； `type` 为画图类型，见 \@ref(sec:plot) 小节图 \@ref(fig:plot-type)； `legend` 决定是否画图例；其它参数用以设置图形细节，如各条均值连线的线条样式等。

(ref:fig-interaction-plot-s) 法国食道癌数据的交互效应图

(ref:fig-interaction-plot) 法国食道癌数据的交互效应图：各饮酒组的折线走势大致一样，说明交互作用很微弱

```{r interaction-plot,fig.width=6.5,fig.height=4,fig.cap="(ref:fig-interaction-plot)",fig.scap="(ref:fig-interaction-plot-s)"}
par(mar = c(4, 4, 0.2, 0.2))
with(esoph, {
  interaction.plot(agegp, alcgp, ncases / (ncases + ncontrols), trace.label = "alcohol",
                   fixed = TRUE, xlab = "Age", ylab = "Cancer Proportion")
  # 方差分析，交互项系数不显著
  summary(aov(ncases / (ncases + ncontrols) ~ agegp * alcgp))
})
```

图 \@ref(fig:interaction-plot)
展示了一批法国食道癌数据的交互效应图。这个数据名为 `esoph`，在 **datasets** 包中，它记录了一组人群的年龄、饮酒量、抽烟量以及是否患食道癌，前三个变量都是以分组形式记录的分类变量。我们不难想象，年龄越高则患食道癌的可能性就会越大，但我们现在关心的问题是，在不同饮酒量水平下，年龄对食道癌的影响是一致的吗？图 \@ref(fig:interaction-plot)
对这个问题的回答大致是肯定的，因为图中各条折线的增长趋势是差不多的，也就是说，不管人群属于哪种饮酒量水平，年龄对患食道癌概率的影响关系都大致一样，但其中也有一些微小的差异，例如年龄组从 35-44 岁 到 45-54 岁，患食道癌的概率在饮酒量大于 40 克/天的人群中会增长大约 20 %，但饮酒量小于 40 克/天的人群中，患食道癌的概率反而略微有所下降，在这里我们可以看到一点交互总用，但总体来说，各饮酒组中，年龄对食道癌的影响方向还是大致一致的。这种似有似无的交互作用可以用方差分析来检验，结果如图 \@ref(fig:interaction-plot)
的代码输出，交互项的 P 值大于 0.05，
说明交互项基本上可以忽略（系数不显著）。总之，从交互效应图看两个分类变量是否有交互作用，只需要看各条折线是否大致平行即可。

我们也可以计算一下每种分组组合下的因变量均值，辅助理解图 \@ref(fig:interaction-plot)：

```{r esoph-mean}
tbl <- aggregate(ncases / (ncases + ncontrols) ~ agegp * alcgp, data = esoph, mean)
colnames(tbl) <- c("agegp", "alcgp", "mean")
reshape(tbl, timevar = "alcgp", idvar = "agegp", direction = "wide", sep = "_")
```

## 分类与回归树图 {#sec:rpart}

分类与回归树（Classification and Regression Tree，CART）是一种递归分割（Recursive Partition）技术，目的是寻找自变量的某种分割，使得样本分割之后因变量各组之间的差异最大。这种分割会一直递归进行下去，直到满足停止条件。详细理论请参见 @Breiman84。

**rpart** 包 [@rpart] 提供了分类与回归树的计算拟合函数 `rpart()` ，该函数包同时也扩充了泛型函数 `plot()` ，凡是 rpart 类型的对象在作图时都会自动调用 `plot.rpart()` 生成树图。`plot.rpart()` 的用法如下：

```{r plot-rpart-usage, results='asis'}
library(rpart)
usage2(usage(rpart:::plot.rpart, output = FALSE))
```


 `x` 是一个 rpart 类型的对象，一般由 `rpart()` 函数拟合产生； `uniform` 决定是否在从上至下的枝节点之间使用相等的纵向距离以避免树枝在某些局部区域靠得太近使图形难以辨认，默认情况下每两个枝节点之间的距离与拟合误差成比例； `branch` 设定树枝的形状，0 为 "V" 字型，1 为垂直的形状，该参数可以取 $[0,1]$ 之间的数值以使得数值形状更像 "V" 或更垂直； `compress` 设定是否在横向上压缩树枝的间距使得图形更紧凑。

我们利用 **rpart** 包中的一个脊椎矫正手术数据 `kyphosis` 来作一棵简单的分类树，如图 \@ref(fig:rpart)。该数据包含一个因变量 `Kyphosis`（术后是否还存在脊椎畸形）和三个自变量 `Age`（年龄，以月计）、`Number`（畸形脊椎的数目）和 `Start`（从上往下数第一段畸形脊椎的位置）。我们希望知道的是这三个自变量对脊椎矫正手术结果的影响，例如怎样特征的小孩手术容易失败。分类与回归树的读法为：每个节点上的条件若满足则树枝向左生长，否则向右生长，每片叶子（最底端，即不再生长枝节的地方）上标明了该处的因变量的预测结果[^rpart-plot]，下方也给出了该叶节点上样本的因变量构成情况。从图 \@ref(fig:rpart) 中可以看出，`Start` 小于 8.5 的小孩的矫正手术容易失败（右边叶节点上有 11 例失败和 8 例成功），而对于 `Start` 大于等于 8.5 的小孩来说，手术结果则需要继续按照自变量拆分：`Start` 大于等于 14.5 的 29 名小孩中，所有小孩的手术均获成功，这表明手术成败的重要因素是小孩的第一段畸形脊椎的位置，这个位置越靠下，则手术越易成功；若前面的条件不满足，则继续向右拆分，下一个拆分变量为年龄，从下面的几个叶节点来看，年龄越大则手术越不容易成功。

[^rpart-plot]: 若因变量为分类变量，则预测值按照多数投票表决（majority vote）原则计算；若为数值变量，则按照叶节点上的样本均值预测。

(ref:fig-rpart-s) 脊椎矫正手术结果的分类树图

(ref:fig-rpart) 脊椎矫正手术结果的分类树图

```{r rpart,fig.width=4,fig.height=3.5,fig.cap="(ref:fig-rpart)",fig.scap="(ref:fig-rpart-s)"}
fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)
par(mar = rep(1, 4), xpd = TRUE)
plot(fit, branch = 0.7)
text(fit, use.n = TRUE, digits = 7)
```

我们还可以将叶节点的信息进一步扩充展示。例如，对于连续型因变量，我们可以将每个叶节点上的样本因变量分布用箱线图或直方图或任何其它展示密度的工具在另一幅图上对应表达出来；对于离散型因变量，则可以利用条形图等工具将样本因变量的频数表达出来。图形的布局可以利用 `layout()` 函数（\@ref(sec:multipage) 小节）等一页多图的方法来实现。关于这样的例子，读者可以参考 @Everitt06 或 @Xie07 等。


## 平行坐标图 {#sec:parcoords}


平行坐标 [@Inselberg07] 是对通常的笛卡尔坐标思维的替代，我们知道，笛卡尔坐标系通常情况下最多只能容纳两个变量（横轴 x 纵轴 y），所以在这样的坐标系下无法直接画出多个变量。当然，前面提到了很多变通方法，使得多元数据可以在笛卡尔坐标系下被表达出来，如 \@ref(sec:symbols) 小节的符号图。平行坐标系的基本做法是将相互垂直的坐标轴改成平行的坐标轴，由于平面上可以容纳很多平行线，所以平行坐标系中可以放置多个变量。在每根坐标轴上，根据变量数值大小描点，如数值越大则点的位置越高，而对于一行观测数据，由于它有多列，每一列都相应对应着一根平行线上的点，最终我们把这些点用折线连起来，也就形成了构成平行坐标图的基本元素。类似地，多行数据就能描绘出多条折线，平行坐标图就是由这些折线加上相应的平行坐标轴构成的。

在 R 中有很多包都可以画平行坐标图，例如 **GGally** 包 [@GGally] 中的 `ggparcoord()` 函数、**MASS** 包 [@Venables02] 中的 `parcoord()` 函数和 **iplots** 包 [@iplots] 中的 `ipcp()` 函数等。由于后面 \@ref(sec:ggplot2) 小节还会专门介绍 **ggplot2**，这里我们先看看这个包中的平行坐标图。 `ggparcoord()` 的用法如下：

```{r ggparcoord-usage, results='asis'}
library(GGally)
usage2(usage(ggparcoord, output = FALSE))
```

\noindent 其中 `data` 是一个数据框，含有多列变量； `columns` 是要参与画图的列，这个列的顺序也决定了每根平行坐标轴的摆放顺序； `scale` 指定标准化数据的方法，可以将列标准化到 $[0, 1]$ 区间上（默认），也可以标准化为均值为 0、方差为 1 的向量，或者不进行标准化。

(ref:fig-ggparcoord-s) 鸢尾花数据的平行坐标图

(ref:fig-ggparcoord) 鸢尾花数据的平行坐标图：花萼长宽和花瓣长宽以及花的种类

```{r ggparcoord,fig.width=4.8,fig.height=2.5,fig.cap="(ref:fig-ggparcoord)",fig.scap="(ref:fig-ggparcoord-s)"}
ggparcoord(iris, columns = 1:4, groupColumn = 5, scale = "uniminmax") + 
  geom_line(size = 1.2)
```


图 \@ref(fig:ggparcoord) 是鸢尾花数据的平行坐标图，数据经过了默认的标准化，取值都在 $[0,1]$ 区间上；其中每条折线代表一朵花。从图中我们可以看出，setosa 这种花的花瓣较小，而另外两种花的花瓣都较大；但 setosa 的花萼特别宽；versicolor 这种花总体来说和 virginica 比较像，只是相对来说尺寸小一些。另外，从图中我们也可以看出相邻变量之间的正向或负向相关关系，例如，由于花萼宽（Sepal.Width）和花瓣长（Petal.Length）两个变量间的线段有很多相交，说明这两个变量有负相关关系，而对于 setosa 这类花来说，由于花萼长和花萼宽这两个变量之间的线段都朝向相同的方向，因此这两个变量在 setosa 这类花中有正向相关关系。这些结论都可以用数值方式验证：

```{r iris-cor}
# 第 2、3 列的相关系数（花萼宽和花瓣长）
cor(iris[, 2:3])
# 第 1、2 列在 setosa 下的相关系数（先对数据取子集）
cor(subset(iris, Species == "setosa", 1:2))
```

为什么平行坐标图中线段相交则意味着负相关、平行则意味着正相关呢？我们退回到平行坐标图的作法就很容易理解了：如果线段大量相交，那么说明第一个变量的大值对应着第二个变量的小值，反之亦然，此大彼小，此小彼大，当然就是负相关了；正相关同理。

此外，由于平行坐标图画出了多个的变量，有时候我们可以借助图中折线的位置来观察聚类现象。若图 \@ref(fig:ggparcoord)
中没有加以颜色标注，读者应该能感觉出所有的数据至少可以分为两类（setosa 和其它），因为花瓣形状小的那些话很可能是单独的一类花，对应着图中偏下的那一簇折线。后面调和曲线图（\@ref(sec:andrews-curve) 小节）与平行坐标图有着相似的外观，它更能体现这里的聚类思想。

需要提醒读者注意的是，平行坐标图中的变量顺序非常重要，它直接影响了图的外观，也限制了我们对数据的观察，尤其是相关关系，因为从平行坐标图中我们只可能观察相邻变量之间的关系。有时候将变量顺序交换一下，则也许可以观察到新的信息。

## 调和曲线图 {#sec:andrews-curve}


调和曲线图由 @Andrews72 提出，它是一种巧妙展示多元数据的技术。我们先介绍一下它的数学原理，然后再说明它为何巧妙。对于一个数据矩阵 $X_{n\times p}$，我们把其中每一行 $X_{i}=\left(X_{i,1},\ldots,X_{i,p}\right)$ 转化为一条曲线：

\begin{equation}
f_{i}(t)=\begin{cases}
\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+\cdots\\
\qquad+X_{i,p-1}\sin(\frac{p-1}{2}t)+X_{i,p}\cos(\frac{p-1}{2}t) & \text{若} p \text{为奇数}\\
\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+\cdots\\
\qquad+X_{i,p}\sin(\frac{p}{2}t) & \text{若} p \text{为偶数}
\end{cases} 
(\#eq:andrews-curve)
\end{equation}

\noindent 其中 $t\in[-\pi,\pi]$。

这样一来，将 $t$ 取一系列值，则每一行观测数据都可以画出一条曲线，最终可以得到 $n$ 条曲线，也就形成了调和曲线图。这种数学转化表面上看起来很不直观，然而它却有很多好的数学性质及对应的实际意义，这里仅列举两条：

1.  如果我们用 $L_{2}$ 范数来度量两条曲线之间的距离，那么得到的距离值正好是欧氏距离平方的 $\pi$ 倍。换句话说，两行观测之间的距离恰好可以表现为图中两条曲线之间的差距。这条性质使得我们可以直观地在图中观察聚类现象和离群点，因为聚类和离群点的概念都是基于距离的（距离的定义有多种，这里用欧氏距离的平方）。如果读者感兴趣，可以验证一下这个 $L_{2}$ 范数的结果：
    $$\int_{-\pi}^{\pi}\left(f_{i}(t)-f_{j}(t)\right)^{2}dt=\pi\sum_{k=1}^{p}\left(X_{i,k}-X_{j,k}\right)^{2}$$

2.  这个变换从一定程度上保持了线性的性质，即：若一个观测 $X_{l}$ 的所有数值都小于 $X_{i}$ 而大于 $X_{j}$，那么在调和曲线图上 $X_{l}$ 对应的曲线也位于 $X_{i}$ 和 $X_{j}$ 之间。这一点性质是非常明显的。

我们尚未发现画调和曲线图的 R 包，因此自行编写了一个函数收录在 **MSG** 包 [@MSG] 中，即 `andrews_curve()`。它的用法如下：

```{r andrews-curve-usage, results='asis'}
library(MSG)
usage2(usage(andrews_curve, output = FALSE))
```

\noindent 其中 x 是数据矩阵； n 为画曲线时 $t$ 在 $[-\pi,\pi]$ 区间上取点的个数，当然，取点越多则曲线越光滑；其它所有参数（包括 ... 参数）都将传递给矩阵图函数 `matplot()` ，用以画每条观测数据的曲线，我们可以设置线的样式等。注意本函数会返回所有行（每条观测）在每个 $t$ 值上对应的 $f_{i}(t)$ 值，我们可以根据这个返回值来判断图中各条曲线对应的行。


(ref:fig-andrews-curve-s) 鸢尾花数据和黑莓树数据的调和曲线图

(ref:fig-andrews-curve) 鸢尾花数据和黑莓树数据的调和曲线图：左上为原始鸢尾花数据，右上为调整变量顺序的鸢尾花数据，左下为标准化之后的鸢尾花数据，右下为标准化之后的黑莓树数据调和曲线图

```{r andrews-curve,fig.width=4.8,fig.height=4.8,fig.cap="(ref:fig-andrews-curve)",fig.scap="(ref:fig-andrews-curve-s)",dev='tikz',fig.showtext=FALSE,fig.process=to_png}
iris.col <- vec2col(iris$Species)
par(mfrow = c(2, 2))
par(mar = c(4, 4, 0.2, 0.2))
andrews_curve(iris[, 1:4], n = 50, col = iris.col, 
              xlab = "$t$", ylab = "$f(t)$")
andrews_curve(iris[, c(3, 4, 2, 1)], n = 50, col = iris.col,
              xlab = "$t$", ylab = "$f(t)$")
andrews_curve(scale(iris[, 1:4]), n = 50, col = iris.col,
              xlab = "$t$", ylab = "$f(t)$")
x <- andrews_curve(scale(trees), n = 50,
                   xlab = "$t$", ylab = "$f(t)$")
# 离群点是哪行数据？即哪行数据对应的 f(t) 会大于 4？
which(apply(x > 4, 1, any))
```

图 \@ref(fig:andrews-curve)
展示了两个多维数据的调和曲线图。左上图为原始鸢尾花数据的前四列，并根据鸢尾花的种类对曲线进行了颜色标注。可以看出，setosa 这一类花的曲线"拧"成了一股，说明这些花之间的距离比较近，也就是我们至少可以观察到这一类的聚类现象。右上图调整了四列的顺序，将花瓣长和花瓣宽两个变量放在了前面，这样做的原因我们后面再解释。这里我们首先可以看到，调整顺序后的鸢尾花调和曲线图发生了变化，曲线的振幅和频率都加大了。这跟数据各列的性质有关。鸢尾花数据有四列，我们可以写出曲线的函数表达式：
$$f_{i}(t)=\frac{X_{i,1}}{\sqrt{2}}+X_{i,2}\sin(t)+X_{i,3}\cos(t)+X_{i,4}\sin(2t)$$

我们知道，$\sin(kt)$ 中的 $k$ 越大，则三角函数曲线的频率越高，而每个三角函数前面的系数越大，则振幅越大。鸢尾花数据前四列的简单汇总信息如下：

```{r iris-summary}
summary(iris[, 1:4])
```


平均来说，第 1、2 列花萼比第 3、4 列花瓣的长宽数值要大，右上图中，由于大数值赋给了 $\sin(2t)$ 的系数，所以导致这一项相对占了主导地位，因此曲线频率加大；同时，由于曲线表达式的第一项理论上取值无界（后面所有项都受三角函数取值界限限制），所以它往往很大影响了曲线的振幅，右图中将小值给了第一项，所以振幅相对左上图加大了。右上图的另一个特征是，setosa 类的曲线几乎一致"拧"在所有曲线之下，这也使得观察聚类更方便。为什么要把第 3、4 列调到前面来呢？主要是因为鸢尾花的四个属性中，用花瓣长宽最易区分各类花，这一点，我们可以用分类树验证一下：


```{r iris-rpart}
library(rpart)
print(rpart(Species ~ ., iris), digits = 2)
```


在数据各列的数量级都差不多的时候， \@ref(eq:andrews-curve) 式越靠前的变量越能控制曲线的位置，越靠后的变量越能控制曲线的波动，而我们通常并不关心调和曲线图中的波动，仅仅观察曲线是否"拧成股"，所以在安排变量顺序的时候，通常把对聚类有重要贡献的变量放在前面，这样调和曲线图对读者来说才能有更好的可读性。

图 \@ref(fig:andrews-curve)
左下图是将鸢尾花数据标准化之后的调和曲线图，由于数据的数量级更加靠近，所以曲线之间的差异也更明显，导致各股曲线更加松散。右下图是标准化之后的黑莓树数据调和曲线图，该数据名为 `trees`，在 **datasets** 包中，数据包含 3 列：周长、高和体积；从图中我们可以观察到有一条曲线明显与其它曲线"不合群"，因此可以初步判断它是一个离群点，由于这条曲线的数值能够超过 4，我们可以用函数返回值来查找它对应的行（事实是第 31 行），代码见图 \@ref(fig:andrews-curve)。

## Hexagon Binning Matrix

## 地图 {#sec:maps}

地图毫无疑问是展示地理信息数据时最直观的工具，尤其是当地图和统计量结合时，其功效则会进一步加强。在本书的第\@ref(cha:history)章中曾经提到过 John Snow 的地图，注意图中不仅标示出了霍乱发生的地点，每个地点的死亡人数也用点的数目标示了出来。历史上还有不少类似的使用地图的例子，而在今天，地理信息系统（GIS）已经成为研究空间和地理数据的热门工具，地图的应用也是屡见不鲜。

地图的本质是多边形（\@ref(sec:polygon) 小节），而多边形的边界则由地理经纬度数据确定。R 中的附加包 **maps** [@maps] 是目前比较完善的地图程序包之一，因此本节主要介绍该程序包。

**maps** 包中核心的函数为 `map()` ，它的用法如下：

```{r map-usage, results='asis'}
library(maps)
usage2(usage(map, output = FALSE))
```

该函数的两个主要参数为地图数据库 `database` 和地图区域 `region` 。地图数据库中包含了所有区域的经纬度数据以及相应的区域名称。在指定一个数据库和一系列区域名称之后，这些区域的地图便可由 `maps()` 生成。其它参数诸如填充颜色、是否画边界、是否添加到现有图形上等这里就不再介绍，请读者参考帮助文件。

(ref:fig-map-s) 2005 年世界各国农业进出口竞争力地图

(ref:fig-map) 2005 年各国农业进出口竞争力地图：农业出口强国在南美，弱国在北非

```{r map,fig.width=6,fig.height=4,fig.cap="(ref:fig-map)",fig.scap="(ref:fig-map-s)",error=TRUE,results='hide'}
demo("AgriComp", package = "MSG")
```

图 \@ref(fig:map)
展示了 2005 年世界各国家地区的农业进出口竞争力指标数据 [@Xie07]，其中我们将竞争力指标简单定义为（出口$-$进口）/（出口$+$进口）。地图上方我们自行添加了颜色图例，从图中可以看出，阿根廷、巴西等南美国家的农业进出口竞争力较强，而利比亚、阿尔及利亚等北非国家的竞争力较弱。该地图的大致制作过程为：首先我们用 `world` 数据库作出一幅空白的世界地图，地区边界用灰色线条表示，然后我们根据竞争力数据中的地区名称与地理数据库中地区名称的对应将数据以颜色的形式表示到世界地图中，最后我们在图中添加了赤道线以及东盟国家（ASEAN）的矩形区域，这是由于作为该图出处的会议论文 [@Xie07] 主题是中澳自由贸易区。

在地理区域上标记大量的数值信息会遇到一个显而易见的困难，就是由于各个地理区域的面积不同而导致地图的解读失真或某些重要地理单元难以辨认。例如，我们在画中国省级地图时，北京和上海等直辖市相比其它省份显得面积太小，此时若用颜色来标记某个数值指标（如 GDP）就会使得各个直辖市的颜色几乎无法辨认。还有另一个更有趣的例子来自 08 年美国总统大选，若用红蓝两种颜色对各个州做标记，以表示该州支持麦凯恩或奥巴马，那么有些面积不大但是权重很大的州（如人口众多的加州）就会影响整幅美国地图，从原始地图上看，似乎麦凯恩会赢，因为他赢得了很多中部面积大的州（但人口稀少），整幅地图看起来以红色为主导，若我们保持州的相对地理位置不变，将各个州的形状进行大小的调整，使其面积与权重成正比，此时红蓝两色的局面就发生了逆转，地图以蓝色为主导色，地图传达信息的偏误才得到了纠正。我们把这种保持地理区域的相对位置不变、调整区域面积与某指标成比例的地图成为"变形地图"（Cartogram），详细内容可阅读 <https://yihui.org/cn/2009/03/cartogram-as-special-maps/>。


https://github.com/XiangyunHuang/MSG-Book/issues/62

## 平滑散点图在地图上形成热力图
